[[tune-for-search-speed]]
== 调整索引速度

[float]
=== 给文件系统缓存更多的内存

为了使搜索更快 Elasticsearch 严重依赖文件系统缓存。通常, 应确保至少有一半的可用内存用于文件系统缓存, 以便 Elasticsearch 可以在物理内存中保留索引的热区域。

[float]
=== 使用更快的硬件

如果你的搜索达到 I/O 瓶颈，你应该考虑给文件系统缓存分配更多的内存（详见以上）或者购买更快的驱动器。特别地，SSD 驱动器的性能比旋转磁盘更好。尽量使用本地存储，应该避免使用远程文件系统如 `NFS` 或者 `SMB`。此外，还应谨慎虚拟化存储，如亚马逊的 "弹性块存储"。
虚拟化存储上 Elasticsearch 工作很好，而且也很有吸引力，因为它非常快而且易于设置。但同时不幸的是，在持续性的基础上，本质上它与专用本地存储相比慢。如果在 `EBS` 上放置索引, 请确保使用预置的 IOPS，否则操作可能会被迅速限制。

如果你的搜索达到 CPU 瓶颈，你应该考虑购买更快的 CPU。

=== 文档建模

应对文档进行建模, 以便搜索时间操作尽可能短。通常，应该避免联接。<<nested,`嵌套`>> 会使查询慢几倍，<<mapping-parent-field,父子>> 关系会使查询慢几百倍。所以如果在没有联接的情况下，通过非规范化文档能够回答相同的问题，搜索预期会出现显著加速。

=== 尽可能搜索更少的字段

一个 <<query-dsl-query-string-query,`查询字符串`>> 或者 <<query-dsl-multi-match-query,`多匹配`>> 查询命中的字段越多越慢。提高多个字段搜索速度的常用方法是在索引时将它们的值复制到单个字段中，然后在搜索时使用此字段这可以通过映射的 <<copy-to,`copy-to`>> 指令自动实现，而不需要修改源文档。下面是一个包含影片的索引示例，该索引的优化查询是将两个值都索引到 ‘name_and_plot’ 字段，通过该字段将电影的名字和情节都检索到。

[source,js]
--------------------------------------------------
PUT movies
{
  "mappings": {
    "_doc": {
      "properties": {
        "name_and_plot": {
          "type": "text"
        },
        "name": {
          "type": "text",
          "copy_to": "name_and_plot"
        },
        "plot": {
          "type": "text",
          "copy_to": "name_and_plot"
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

=== 预索引数据

你应该利用查询中的模式来优化数据的索引方式。例如，你的所有文档中都有 ‘price’ 字段，并且大部分的查询在固定的范围列表中运行 <<search-aggregations-bucket-range-aggregation,`范围`>> 聚合。你可以通过将范围预索引到索引中，并且使用 <<search-aggregations-bucket-terms-aggregation,`字段`>> 使得聚合更快。

举个例子，如果文档像下面这样：

[source,js]
--------------------------------------------------
PUT index/_doc/1
{
  "designation": "spoon",
  "price": 13
}
--------------------------------------------------
// CONSOLE

搜索请求看起来是这样：

[source,js]
--------------------------------------------------
GET index/_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "ranges": [
          { "to": 10 },
          { "from": 10, "to": 100 },
          { "from": 100 }
        ]
      }
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

在索引时文档可以增加 `price_range` 字段。搜索请求可以聚合这个新字段, 而不是在 "价格" 字段上运行 "范围" 聚合。

=== 标识符应该被映射成 <<keyword,`关键字`>>。

[source,js]
--------------------------------------------------
PUT index
{
  "mappings": {
    "_doc": {
      "properties": {
        "price_range": {
          "type": "keyword"
        }
      }
    }
  }
}

PUT index/_doc/1
{
  "designation": "spoon",
  "price": 13,
  "price_range": "10-100"
}
--------------------------------------------------
// CONSOLE



[source,js]
--------------------------------------------------
GET index/_search
{
  "aggs": {
    "price_ranges": {
      "terms": {
        "field": "price_range"
      }
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

=== 将标识符映射为 "关键字"

事实上有些数据是数字但并不意味着它始终应该被映射成 <<number,`数值字段`>>。Elasticsearch 索引数值的优化方式，在 `keyword` 字段上`范围`查询优于`分词`查询。通常, 存储标识符 (如 `ISBN` 或标识其他数据库中记录的任何数字)的字段很少在 `范围` 查询或聚合中使用。这就是为什么映射成 `keyword` 比 `integer` 或者 `long` 有益。

=== 避免脚本

通常，脚本应该避免。如果确实需要，你应该倾向于 `painless` 和 `expressions` 引擎。

=== 搜索日期四舍五入

在日期字段上使用 `now` 的查询通常是不可缓存的，因为正在匹配的范围一直在变。但是在用户体验方面切换到四舍五入的日期通常是可以接受的，并且可以很好地利用查询缓存。例如下面的查询：

[source,js]
--------------------------------------------------
PUT index/_doc/1
{
  "my_date": "2016-05-11T16:30:55.328Z"
}

GET index/_search
{
  "query": {
    "constant_score": {
      "filter": {
        "range": {
          "my_date": {
            "gte": "now-1h",
            "lte": "now"
          }
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

可以用下面的查询替换：

[source,js]
--------------------------------------------------
GET index/_search
{
  "query": {
    "constant_score": {
      "filter": {
        "range": {
          "my_date": {
            "gte": "now-1h/m",
            "lte": "now/m"
          }
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

在案例中我们舍入了分钟，所以如果当前时间是 `16:31:29`，范围查询将匹配 `my_date` 字段值介于 `15:31` 和 `16:31` 之间的所有内容。如果多个用户在同一分钟内运行包含此范围的查询, 则查询缓存可以帮助加快速度。舍入的时间间隔越长, 查询缓存的帮助就越大，但请注意，过于激进的舍入也可能会损害用户体验。

注: 为了能够利用查询缓存, 将范围拆分为较大的可缓存部分和较小的不可缓存部分可能很诱人, 如下所示:


[source,js]
--------------------------------------------------
GET index/_search
{
  "query": {
    "constant_score": {
      "filter": {
        "bool": {
          "should": [
            {
              "range": {
                "my_date": {
                  "gte": "now-1h",
                  "lte": "now-1h/m"
                }
              }
            },
            {
              "range": {
                "my_date": {
                  "gt": "now-1h/m",
                  "lt": "now/m"
                }
              }
            },
            {
              "range": {
                "my_date": {
                  "gte": "now/m",
                  "lte": "now"
                }
              }
            }
          ]
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

但是, 这种做法可能会使查询在某些情况下运行速度变慢, 因为引入 `bool` 的开销会大于利用查询缓存节省的开销。 

=== 强制合并只读索引

只读索引会受益于设置成 <<indices-forcemerge,合并成单独的段>>。基于时间的索引通常是这样的：当前时间帧的索引才会获取新文档，旧索引是只读的。

重要提示：不要强制合并正在写入的索引，将合并保留到后台合并进程。

=== 预热全局序号

全局序号是一种用来在 <<keyword,`keyword`>> 字段上运行<<search-aggregations-bucket-terms-aggregation,`terms`>> 聚合的数据结构。他们在内存中是懒加载的，因为 Elasticsearch 并不知道哪些字段会用于 `term` 聚合，哪些不会。通过如下所示配置映射，你可以告诉 Elasticsearch 在刷新时先加载全局序号：

[source,js]
--------------------------------------------------
PUT index
{
  "mappings": {
    "_doc": {
      "properties": {
        "foo": {
          "type": "keyword",
          "eager_global_ordinals": true
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE


=== 预热文件系统缓存

如果运行 Elasticsearch 的机器重启，文件系统的缓存会被清空，因此，在操作系统将索引的热区加载到内存之前需要一段时间，以便快速执行搜索操作。你可以使用 <<file-system,`index.store.preload`>> 设置，你可以明确的告诉操作系统，根据文件扩展名哪些文件应该先被加载到内存中。

警告：如果文件系统缓存不够大，无法容纳所有数据，那么太多索引或太多文件的数据加载到文件系统缓存中会使搜索速度变慢。小心使用。


=== 使用索引排序加速连词

<<index-modules-index-sorting,Index sorting>>  可以用于以稍慢索引的代价使连词更快。在 <<index-modules-index-sorting-conjunctions,index sorting documentation>> 中了解更多信息。

=== 使用 `preference` 优化内存使用率

有多个缓存可以帮助搜索性能，例如 https://en.wikipedia.org/wiki/Page_cache[文件系统缓存]、<<shard-request-cache,请求缓存>> 或者 <<query-cache,查询缓存>>。然而，所有缓存都是节点级别维护的，一位置如果你连续两次运行相同的请求，则会有一个或者多个  <<glossary-replica-shard,副本>> 并且使用默认路由算法 https://en.wikipedia.org/wiki/Round-robin_DNS[轮询]，这两个请求会转到不同的分片副本上，阻碍节点级的缓存帮助。

由于搜索应用的用户连续运行相似的请求很常见，例如为了分析索引的较窄子集，使用标识当前用户或会话的首选项值可以帮助优化缓存的使用。

=== 副本可能有助于提高吞吐量，但并非总是如此

除了提高弹性之外，副本也能提高吞吐量。例如，你有一个单分片的索引和三个节点，你需要将副本的数量设置成 2，以便你总分片有 3 份副本，这样所有的节点都利用起来。

现在假设你有 2 分片索引和两个节点，一种情况副本数是 0，意味着每个节点仅有一个分片。第二种情况副本数是 1，意味着每个节点有 2 个分片。哪种设置在搜索性能方面表现更好？通常，每个节点总的分片数越少的设置性能表现越好。原因是它为每个分片提供的文件系统缓存份额更大，文件系统缓存可能是 Elasticsearch 第一性能因素。同时，请注意，单个节点故障的情况下，没有副本的设置也会同时故障，所以这是吞吐量和可用性之间的权衡。

那么，正确的副本数量是多少？如果你的集群有 `num_nodes` 个节点，_总共_ `num_primaries` 个主分片，如果你想一次最多能处理 `max_failures` 节点故障，那么正确的副本数是：
`max(max_failures, ceil(num_nodes / num_primaries) - 1)`。

=== 启用自适应副本选择

当存在多个数据副本时，Elasticsearch 可以使用一组称为 <<search-adaptive-replica,自适应副本选择>> 的准则，根据每个包含副本分片节点的响应时间、服务时间和队列大小来选择数据的最佳副本。这可以提高查询吞吐量并减少搜索量大的应用程序的延迟。