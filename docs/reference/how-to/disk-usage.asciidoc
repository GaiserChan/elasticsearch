[[tune-for-disk-usage]]
== 调整磁盘使用情况


=== 禁用不必要的特性

默认情况下，Elasticsearch 会对大部分的字段进行索引及追加文档值，以便这些字段能够开箱即用地被搜索和聚合。例如，你有一个名为 `foo` 的数值型字段需要在直方图上显示，但是从来不会对它进行过滤，
这样就可以安全地在你的 <<mappings,mappings>>  里对这个字段禁用索引：

[source,js]
--------------------------------------------------
PUT index
{
  "mappings": {
    "type": {
      "properties": {
        "foo": {
          "type": "integer",
          "index": false
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

<<text,`text`>> 字段存储了归一化因子，以便能够对文档进行评分。如果你只是在 text 字段上使用匹配功能，而不关心生成的评分，你可以修改 Elasticsearch 的配置对该字段不写入归一化因子：

[source,js]
--------------------------------------------------
PUT index
{
  "mappings": {
    "type": {
      "properties": {
        "foo": {
          "type": "text",
          "norms": false
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

<<text,`text`>> 字段同时也默认存储了它在文档中出现的频次和位置，频次用于计算文档评分，位置用于短语查询。如果你不进行短语查询，你可以告诉 Elasticsearch 不存储索引位置：

[source,js]
--------------------------------------------------
PUT index
{
  "mappings": {
    "type": {
      "properties": {
        "foo": {
          "type": "text",
          "index_options": "freqs"
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

另外，如果你也不关心评分，你可以通过如下配置 Elasticsearch 来调整每次 term 索引到的文档，你仍然能够在这个字段上搜索，但是短语查询会报错，评分也会假设该 term 在文档中只出现一次。

[source,js]
--------------------------------------------------
PUT index
{
  "mappings": {
    "type": {
      "properties": {
        "foo": {
          "type": "text",
          "norms": false,
          "index_options": "freqs"
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

[float]
=== 不使用默认的动态字符串映射

默认的  <<dynamic-mapping, 动态字符串映射>> 会将字符串字段索引为 <<text,`text`>> 和 <<keyword,`keyword`>> 。如果你只需要其中一个，这样是非常浪费的。通常情况下，`id` 字段只需要索引为 `keyword`，`body` 字段只需要索引为 `text`。

同样可以通过配置字符串字段的显示映射或者设置动态模板禁用动态字符串索引，这样字符串字段将被映射成 `text` 或者 `keyword`。

举例，下面的模板可以用作将字符串字段映射成 `keyword`:

[source,js]
--------------------------------------------------
PUT index
{
  "mappings": {
    "type": {
      "dynamic_templates": [
        {
          "strings": {
            "match_mapping_type": "string",
            "mapping": {
              "type": "keyword"
            }
          }
        }
      ]
    }
  }
}
--------------------------------------------------
// CONSOLE

[float]
=== 查看你的分片大小

较大的分片在存储数据时更有效率。要增加分片的大小，你可以减少一个索引中主分片的数量，这可以通过 <<indices-create-index,创建索引>> 时配置较少的主分片，创建较少的索引（例如，利用 <<indices-rollover-index,Rollover API>> ）或者使用 <<indices-shrink-index,Shrink API>> 修改已经存在的索引。

要记住，分片越大，数据恢复时间越长。

[float]
=== 禁用 `_all`

<<mapping-all-field,`_all`>> 字段索引了一个文档中的所有字段值，这会占用大量的空间，如果你永远不需要同时搜索所有字段, 则可以将其禁用。

[float]
=== 禁用 `_source`

<<mapping-source-field,`_source`>> 字段存储了文档的原始 JSON 体，你如果不需要访问可以禁用它。但是，需要访问 `_source` 字段的 API （如：更新和重建索引）将不可用。

[float]
=== 使用 `best_compression`

`_source` 和存储的字段占用的磁盘空间不容忽视。使用 `best_compression`<<index-codec,codec>> 可以很好地压缩它们。

[float]
=== 强制合并

Elasticsearch 中的索引都是被存储在一个或者多个分片中。每个分片都是 Lucene 索引，并且由一个或者多个分段（磁盘上的真实文件）组成。大的分段在存储数据上更有效率。

<<indices-forcemerge,`_forcemerge` 接口>>  可以用于减少每个分片上的分段数量。多数情况下, 通过设置  "max_num_segments=1", 可以将分段的数量减少到每个分片一个。

[float]
=== 缩小索引

<<indices-shrink-index,Shrink 接口>>  允许你减少索引中的分片数，同上面强制合并的接口一起，可以显著减少分片的数量和索引的分段。

[float]
=== 使用最小数字类型就足够

为<<number, 数值数据>>选择的类型会对磁盘有显著影响。特别地，整数应该用整型（`byte`, `short`, `integer` 或者  `long`）存储，浮点数应该用 `scaled_float` 存储，如果合适或者在案例中使用最小类型足够，使用 "float" 代替 "double" 或者使用 "half_float" 代替 "float" 将有助于节省存储。

[float]
=== 使用索引排序查找相似的文档

Elasticsearch 存储 `_source` 字段时，为了提高整体的压缩比，它会一次性压缩多个文档。例如，文档之间共用相同的字段很常见，共享字段值也相当常见，特别是某些基数很低或者 https://en.wikipedia.org/wiki/Zipf%27s_law[zipfian] 分布的字段。

默认情况下，文档按照写入到索引的顺序一起压缩。如果你启用 <<index-modules-index-sorting,索引排序>>，它们将按照排序顺序进行压缩。对具有相似结构，字段和值的文档进行排序应该可以提高压缩率。

[float]
=== 在文档中以相同的顺序放置字段

由于多文档是一起被压缩到磁盘块中，如果字段都是以相同顺序出现，elasticsearch 更容易在这些 ‘_source’ 文档中找到更长的重复字符串。

