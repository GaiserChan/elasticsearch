[[mixing-exact-search-with-stemming]]
=== 将精确搜索与分词混合

在构建搜索应用程序时，分词通常是必须的，因为 `skiing` 查询需要匹配包含 `ski` 和 `skis` 的文档。但是用户想明确地搜索 `skiing` 呢？实现这一点的典型方法是使用 <<multi-fields,multi-field>> 以两种不同的方式索引相同的内容：

[source,js]
--------------------------------------------------
PUT index
{
  "settings": {
    "analysis": {
      "analyzer": {
        "english_exact": {
          "tokenizer": "standard",
          "filter": [
            "lowercase"
          ]
        }
      }
    }
  },
  "mappings": {
    "_doc": {
      "properties": {
        "body": {
          "type": "text",
          "analyzer": "english",
          "fields": {
            "exact": {
              "type": "text",
              "analyzer": "english_exact"
            }
          }
        }
      }
    }
  }
}

PUT index/_doc/1
{
  "body": "Ski resort"
}

PUT index/_doc/2
{
  "body": "A pair of skis"
}

POST index/_refresh
--------------------------------------------------
// CONSOLE

有了这样的设置，搜索 `body` 字段的 `ski` 将会返回两个文档：

[source,js]
--------------------------------------------------
GET index/_search
{
  "query": {
    "simple_query_string": {
      "fields": [ "body" ],
      "query": "ski"
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

[source,js]
--------------------------------------------------
{
  "took": 2,
  "timed_out": false,
  "_shards": {
    "total": 5,
    "successful": 5,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total": 2,
    "max_score": 0.2876821,
    "hits": [
      {
        "_index": "index",
        "_type": "_doc",
        "_id": "2",
        "_score": 0.2876821,
        "_source": {
          "body": "A pair of skis"
        }
      },
      {
        "_index": "index",
        "_type": "_doc",
        "_id": "1",
        "_score": 0.2876821,
        "_source": {
          "body": "Ski resort"
        }
      }
    ]
  }
}
--------------------------------------------------
// TESTRESPONSE[s/"took": 2,/"took": "$body.took",/]

另一方面，在 `body.exact` 字段上搜索 `ski` 将只返回文档 `1`，因为 `body.exact` 的分析链不执行分词。

[source,js]
--------------------------------------------------
GET index/_search
{
  "query": {
    "simple_query_string": {
      "fields": [ "body.exact" ],
      "query": "ski"
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

[source,js]
--------------------------------------------------
{
  "took": 1,
  "timed_out": false,
  "_shards": {
    "total": 5,
    "successful": 5,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total": 1,
    "max_score": 0.2876821,
    "hits": [
      {
        "_index": "index",
        "_type": "_doc",
        "_id": "1",
        "_score": 0.2876821,
        "_source": {
          "body": "Ski resort"
        }
      }
    ]
  }
}
--------------------------------------------------
// TESTRESPONSE[s/"took": 1,/"took": "$body.took",/]

这不是容易像最终用户公开的内容，因为我们需要有种方法来确定他们是否在查找完全匹配的内容，并相应的重定向到适当的字段。另外，如果只有部分查询需要完全匹配，而其他部分仍然考虑分词，该怎么办？

幸运的是，`query_string` 和 `simple_query_string` 查询有一个特性可以解决这个问题： `quote_field_suffix`。这告诉 Elasticsearch，引号之间出现的单词将被重定向到一个不同的字段，详见以下内容：

[source,js]
--------------------------------------------------
GET index/_search
{
  "query": {
    "simple_query_string": {
      "fields": [ "body" ],
      "quote_field_suffix": ".exact",
      "query": "\"ski\""
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

[source,js]
--------------------------------------------------
{
  "took": 2,
  "timed_out": false,
  "_shards": {
    "total": 5,
    "successful": 5,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total": 1,
    "max_score": 0.2876821,
    "hits": [
      {
        "_index": "index",
        "_type": "_doc",
        "_id": "1",
        "_score": 0.2876821,
        "_source": {
          "body": "Ski resort"
        }
      }
    ]
  }
}
--------------------------------------------------
// TESTRESPONSE[s/"took": 2,/"took": "$body.took",/]

在上面例子中，`ski` 在引号之间，由于 `quote_field_suffix` 参数，所以它能够在 `body.exact` 字段中搜索到，只有文档 `1` 匹配到。这样允许用户根据他们的喜好将精确搜索和分词搜索混合使用。